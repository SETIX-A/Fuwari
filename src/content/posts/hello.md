---
title: Hello
published: 2025-08-25
description: ä¸€ç¯‡ç®€å•çš„ Markdown åšå®¢æ–‡ç« ç¤ºä¾‹ã€‚
tags:
  - Obsidian
  - æ¼”ç¤º
category: Obsidian
draft: true
---
# Obsidian ç¡çœ è‡ªåŠ¨åŒ–ç»ˆææŒ‡å—ï¼šä»æ‰‹åŠ¨æŠ“ç‹‚åˆ°ä¸€é”®è¿½è¸ªä¸å¯è§†åŒ–

å¤§å®¶å¥½ï¼æˆ‘æ˜¯ç¬¬ä¸€æ¬¡å†™åšå®¢çš„æ–°æ‰‹ï¼Œå¦‚æœä½ åœ¨æ—¥å¸¸ç”Ÿæ´»ä¸­ä¸ºè®°å½•ç¡çœ æ—¶é—´è€Œçƒ¦æ¼â€”â€”æ¯å¤©æ‰‹åŠ¨è¾“å…¥æ•°æ®ã€è®¡ç®—æ—¶é•¿ï¼Œè¿˜å¾—æ‰‹åŠ¨ç»˜åˆ¶å›¾è¡¨â€”â€”é‚£ä¹ˆè¿™ç¯‡æ–‡ç« å°±æ˜¯ä¸ºä½ é‡èº«æ‰“é€ çš„ã€‚æˆ‘æ›¾ç»èŠ±äº†æ•´æ•´6ä¸ªå°æ—¶è°ƒè¯•å„ç§å‘ï¼Œæœ€ç»ˆæ­å»ºå‡ºä¸€å¥—å…¨è‡ªåŠ¨çš„Obsidianç¡çœ è¿½è¸ªç³»ç»Ÿã€‚ç°åœ¨ï¼Œæˆ‘å°†ä¸€æ­¥æ­¥å¸¦ä½ ä»é›¶å®ç°å®ƒï¼Œåªéœ€15åˆ†é’Ÿï¼Œä½ å°±èƒ½äº«å—åˆ°â€œä¸€é”®ç¡è§‰ã€ä¸€é”®èµ·åºŠâ€çš„æè‡´ä¾¿åˆ©ï¼Œä»¥åŠè‡ªåŠ¨ç”Ÿæˆçš„ç¡çœ æ•°æ®å¯è§†åŒ–å›¾è¡¨ã€‚

ä¸ºä»€ä¹ˆé€‰æ‹©Obsidianï¼Ÿå®ƒå…è´¹ã€å¼€æºã€æ”¯æŒæ’ä»¶æ‰©å±•ï¼Œèƒ½å°†ç¬”è®°è½¬åŒ–ä¸ºå¼ºå¤§çš„æ•°æ®ç®¡ç†ç³»ç»Ÿã€‚è·Ÿéšæˆ‘çš„æŒ‡å—ï¼Œä½ å°†å­¦ä¼šå¦‚ä½•ç”¨æ’ä»¶è‡ªåŠ¨åŒ–è®°å½•ç¡çœ ï¼Œå¹¶é€šè¿‡å›¾è¡¨æ´å¯Ÿä½ çš„ä½œæ¯ä¹ æƒ¯ã€‚å‡†å¤‡å¥½äº†å—ï¼Ÿè®©æˆ‘ä»¬å¼€å§‹å§ï¼

## æœ€ç»ˆæ•ˆæœé¢„è§ˆ

æƒ³è±¡ä¸€ä¸‹è¿™æ ·çš„åœºæ™¯ï¼š
1. **æ™šä¸Šå‡†å¤‡ç¡è§‰æ—¶**ï¼šæŒ‰ä¸€ä¸ªå¿«æ·é”®ï¼Œç³»ç»Ÿè‡ªåŠ¨åœ¨ä½ çš„ç¡çœ æ—¥è®°ä¸­æ·»åŠ ä¸€è¡Œè®°å½•ï¼Œå¦‚ `- [date:: 2025-08-24], [bed:: 23:58], [wake:: ]`ã€‚å®ƒç”šè‡³èƒ½æ™ºèƒ½åˆ¤æ–­å‡Œæ™¨ç¡è§‰ï¼ˆä¾‹å¦‚å‡Œæ™¨3ç‚¹ï¼‰ï¼Œå¹¶å°†æ—¥æœŸå½’ä¸ºå‰ä¸€å¤©ã€‚
2. **æ—©ä¸Šèµ·åºŠæ—¶**ï¼šæŒ‰å¦ä¸€ä¸ªå¿«æ·é”®ï¼Œç³»ç»Ÿè‡ªåŠ¨æ‰¾åˆ°æ˜¨æ™šçš„æœªå®Œæˆè®°å½•ï¼Œè¡¥å…¨èµ·åºŠæ—¶é—´ï¼Œå¹¶è®¡ç®—ç¡çœ æ—¶é•¿ï¼Œå¦‚ `- [date:: 2025-08-24], [bed:: 23:58], [wake:: 08:15], [duration:: 08:17]`ã€‚
3. **æ•°æ®å¯è§†åŒ–**ï¼šåœ¨ä»»æ„ç¬”è®°ä¸­æ’å…¥ä¸€æ®µä»£ç ï¼Œå°±èƒ½ç”Ÿæˆç¡çœ æ—¶é•¿è¶‹åŠ¿å›¾ã€å¹³å‡å…¥ç¡/èµ·åºŠæ—¶é—´åˆ†å¸ƒå›¾ï¼Œä»¥åŠæŒ‰æœˆ/å¹´ç»Ÿè®¡è¡¨æ ¼ã€‚æ‰€æœ‰æ•°æ®å®æ—¶æ›´æ–°ï¼Œä¸€ç›®äº†ç„¶ã€‚

è¿™ä¸ä»…ä»…æ˜¯è®°å½•ï¼Œæ›´æ˜¯å¸®åŠ©ä½ ä¼˜åŒ–ç¡çœ ã€æå‡ç”Ÿæ´»è´¨é‡çš„å·¥å…·ã€‚

## æ‰€éœ€å·¥å…·

- **[Obsidian](https://obsidian.md/)**ï¼ˆå…è´¹ä¸‹è½½è‡ªå®˜ç½‘ï¼‰ã€‚
- **æ’ä»¶**ï¼ˆåœ¨Obsidianè®¾ç½® > ç¤¾åŒºæ’ä»¶ä¸­å®‰è£…å¹¶å¯ç”¨ï¼‰ï¼š
  - **Templater**ï¼šæ ¸å¿ƒæ’ä»¶ï¼Œç”¨äºè¿è¡ŒJavaScriptè„šæœ¬ï¼Œå®ç°è‡ªåŠ¨åŒ–è®°å½•å’Œå¿«æ·å‘½ä»¤ã€‚
  - **Dataview**ï¼šç”¨äºæŸ¥è¯¢æ•°æ®å¹¶ç”Ÿæˆå›¾è¡¨ï¼Œæ”¯æŒåŠ¨æ€å¯è§†åŒ–ã€‚

å®‰è£…æ’ä»¶åï¼Œé‡å¯Obsidianä»¥ç¡®ä¿ç”Ÿæ•ˆã€‚å¦‚æœä½ ç”¨çš„æ˜¯ç§»åŠ¨ç«¯ï¼Œç¡®ä¿æ’ä»¶å…¼å®¹ã€‚

## Part 1: é…ç½®Templateræ¨¡æ¿â€”â€”è‡ªåŠ¨åŒ–è®°å½•çš„æ ¸å¿ƒè„šæœ¬

Templateræ’ä»¶å…è®¸æˆ‘ä»¬åœ¨æ¨¡æ¿ä¸­ä½¿ç”¨JavaScriptä»£ç ï¼Œå®ç°åŠ¨æ€é€»è¾‘ã€‚é¦–å…ˆï¼Œåœ¨Obsidianè®¾ç½®ä¸­é…ç½®Templaterçš„æ¨¡æ¿æ–‡ä»¶å¤¹ï¼ˆä¾‹å¦‚åˆ›å»ºä¸€ä¸ªåä¸ºâ€œTemplatesâ€çš„æ–‡ä»¶å¤¹ï¼Œè·¯å¾„ä¸ºâ€œTemplates/â€ï¼‰ã€‚

### æ¨¡æ¿1ï¼šè®°å½•ç¡è§‰æ—¶é—´ï¼ˆbed.mdï¼‰

è¿™ä¸ªæ¨¡æ¿è´Ÿè´£æ–°å»ºç¡çœ è®°å½•ã€‚å®ƒä¼šè‡ªåŠ¨å¤„ç†å‡Œæ™¨åœºæ™¯ï¼Œç¡®ä¿æ—¥æœŸæ­£ç¡®ã€‚

åœ¨â€œTemplatesâ€æ–‡ä»¶å¤¹ä¸‹åˆ›å»º`bed.md`æ–‡ä»¶ï¼Œç²˜è´´ä»¥ä¸‹ä»£ç ï¼š

````
```javascript
<%*
// --- é…ç½®åŒº ---
const sleepLogFile = "ç¡çœ æ—¥è®°-2025.md"; // ä½ çš„ç¡çœ æ—¥å¿—è·¯å¾„ï¼ˆå¯è‡ªå®šä¹‰æ–‡ä»¶å¤¹ï¼Œå¦‚"è®°å½•/ç¡çœ æ—¥è®°-2025.md"ï¼‰
// --- ç»“æŸé…ç½® ---

const now = tp.date.now();
const hour = parseInt(tp.date.now("H"));

// å…³é”®é€»è¾‘ï¼šå¦‚æœåœ¨å‡Œæ™¨5ç‚¹å‰è®°å½•ï¼Œæ—¥æœŸè‡ªåŠ¨ç®—ä½œå‰ä¸€å¤©
const dateString = (hour < 5) ? tp.date.now("YYYY-MM-DD", -1) : tp.date.now("YYYY-MM-DD");
const bedTime = tp.date.now("HH:mm");

// \nç¡®ä¿æ€»æ˜¯åœ¨æ–°çš„ä¸€è¡Œæ·»åŠ 
const newEntry = `\n- [date:: ${dateString}], [bed:: ${bedTime}], [wake:: ]`;

const file = tp.file.find_tfile(sleepLogFile);
if (!file) {
    new Notice(`âŒ é”™è¯¯ï¼šæ‰¾ä¸åˆ°æ–‡ä»¶ "${sleepLogFile}"`, 5000);
    return;
}

await tp.app.vault.append(file, newEntry);
new Notice(`ğŸ›Œ å·²è®°å½•ç¡è§‰æ—¶é—´: ${bedTime}`, 3000);
%>
```

### æ¨¡æ¿2ï¼šè®°å½•èµ·åºŠæ—¶é—´ï¼ˆwake.mdï¼‰

è¿™ä¸ªæ¨¡æ¿ä¼šæ‰«ææ—¥å¿—æ–‡ä»¶ï¼Œæ‰¾åˆ°æœ€åä¸€æ¡æœªå®Œæˆçš„è®°å½•ï¼Œè¡¥å…¨èµ·åºŠæ—¶é—´å¹¶è®¡ç®—æ—¶é•¿ã€‚

åœ¨åŒä¸€æ–‡ä»¶å¤¹ä¸‹åˆ›å»º`wake.md`æ–‡ä»¶ï¼Œç²˜è´´ä»¥ä¸‹ä»£ç ï¼š

```javascript
<%*
// ä½¿ç”¨ä¸€ä¸ªç«‹å³æ‰§è¡Œçš„å¼‚æ­¥å‡½æ•° (IIFE) æ¥ç¡®ä¿ä»£ç çš„ç¨³å®šæ€§å’Œä½œç”¨åŸŸéš”ç¦»
(async () => {
    // --- é…ç½® ---
    const filePath = 'ç¡çœ æ—¥è®°-2025.md'; // ä½ çš„ç¡çœ æ—¥å¿—æ–‡ä»¶å
    const morningCutoffHour = 5; // æ—©ä¸Šå‡ ç‚¹å‰ç¡è§‰ï¼Œä»ç®—ä½œå‰ä¸€å¤©çš„ç¡çœ å‘¨æœŸ
    // --- ç»“æŸé…ç½® ---
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file) {
        new Notice(`é”™è¯¯ï¼šæ‰¾ä¸åˆ°æ–‡ä»¶ ${filePath}`, 5000);
        return;
    }
    try {
        const content = await this.app.vault.read(file);
        const lines = content.split('\n');
        let updated = false;
        for (let i = lines.length - 1; i >= 0; i--) {
            let line = lines[i];
            if (line.includes('[bed::') && line.includes('[wake:: ]')) {
                const match = line.match(/\[date:: (.*?)\].*\[bed:: (.*?)\]/);

                if (match && match[1] && match[2]) {
                    const dateStr = match[1]; // è¿™æ˜¯ç¡çœ å½’å±çš„æ—¥æœŸ, e.g., "2025-08-23"
                    const bedTimeStr = match[2]; // e.g., "02:57"
                    
                    // --- æ ¸å¿ƒæ™ºèƒ½é€»è¾‘å¼€å§‹ ---
                    const bedHour = parseInt(bedTimeStr.split(':')[0], 10);
                    const bedDateAnchor = moment(dateStr); // è·å–ç¡çœ å½’å±æ—¥æœŸ
                    // å¦‚æœç¡è§‰æ—¶é—´åœ¨å‡Œæ™¨ï¼Œé‚£ä¹ˆå®ƒçš„å®é™…æ—¥å†æ—¥æœŸæ˜¯â€œå½’å±æ—¥æœŸâ€çš„åä¸€å¤©
                    if (bedHour < morningCutoffHour) {
                        bedDateAnchor.add(1, 'day');
                    }
                    
                    // æ„å»ºå‡ºçœŸå®çš„ç¡è§‰æ—¶é—´æˆ³
                    const bedMoment = moment(`${bedDateAnchor.format('YYYY-MM-DD')} ${bedTimeStr}`);
                    // --- æ ¸å¿ƒæ™ºèƒ½é€»è¾‘ç»“æŸ ---
                    const wakeMoment = moment(); // è·å–çœŸå®çš„èµ·åºŠæ—¶é—´æˆ³
                    
                    const duration = moment.duration(wakeMoment.diff(bedMoment));
                    const hours = Math.floor(duration.asHours());
                    const minutes = duration.minutes();
                    
                    const wakeTimeFormatted = wakeMoment.format('HH:mm');
                    const durationFormatted = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
                    
                    const updatedLine = line.replace(
                        '[wake:: ]', 
                        `[wake:: ${wakeTimeFormatted}], [duration:: ${durationFormatted}]`
                    );
                    
                    lines[i] = updatedLine;
                    updated = true;

                    new Notice(`èµ·åºŠæˆåŠŸï¼ğŸ‰\nç¡çœ æ—¶é•¿: ${hours} å°æ—¶ ${minutes} åˆ†é’Ÿ`, 6000);//è‡ªå®šä¹‰å¼¹å‡ºä¿¡æ¯
                    break; 
                }
            }
        }
        if (updated) {
            const newContent = lines.join('\n');
            await this.app.vault.modify(file, newContent);
        } else {
            new Notice('æœªæ‰¾åˆ°éœ€è¦æ›´æ–°çš„ç¡çœ è®°å½•ã€‚', 5000);
        }
    } catch (error) {
        console.error("Templater è„šæœ¬ 'tpl-sleep-wake' å‡ºç°é”™è¯¯:", error);
        new Notice("è®°å½•èµ·åºŠå¤±è´¥ï¼Œè¯·æ£€æŸ¥å¼€å‘è€…æ§åˆ¶å°è·å–æ›´å¤šä¿¡æ¯ã€‚", 10000);
    }
})();
%>
```

**æç¤º**ï¼šè¿™äº›è„šæœ¬ä¾èµ–`moment.js`ï¼ˆTemplaterå†…ç½®æ”¯æŒï¼‰ã€‚æµ‹è¯•æ—¶ï¼Œå…ˆåˆ›å»ºä¸€ä¸ªç©ºçš„`ç¡çœ æ—¥è®°-2025.md`æ–‡ä»¶ï¼Œç¡®ä¿è·¯å¾„æ­£ç¡®ã€‚

## Part 2: é…ç½®å¿«æ·å‘½ä»¤â€”â€”ä¸€é”®è§¦å‘è‡ªåŠ¨åŒ–

ç°åœ¨ï¼Œè®©è¿™äº›æ¨¡æ¿å˜å¾—æ˜“ç”¨ã€‚é€šè¿‡Templaterçš„â€œTemplate Hotkeysâ€åŠŸèƒ½ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ¨¡æ¿ç»‘å®šåˆ°å‘½ä»¤é¢æ¿æˆ–çƒ­é”®ã€‚

1. **è®¾ç½®Templateræ¨¡æ¿æ–‡ä»¶å¤¹**ï¼š
   - æ‰“å¼€Obsidianè®¾ç½® > ç¤¾åŒºæ’ä»¶ > Templaterã€‚
   - åœ¨â€œTemplate folder locationâ€ä¸­è¾“å…¥ä½ çš„æ¨¡æ¿æ–‡ä»¶å¤¹è·¯å¾„ï¼ˆå¦‚â€œTemplates/â€ï¼‰ã€‚

2. **æ·»åŠ ä¸“ç”¨å‘½ä»¤**ï¼ˆæ¨èï¼Œè®©æ¨¡æ¿ç›´æ¥å‡ºç°åœ¨å‘½ä»¤é¢æ¿ï¼‰ï¼š
   - åœ¨Templaterè®¾ç½®ä¸­ï¼Œæ»šåŠ¨åˆ°â€œTemplate Hotkeysâ€ã€‚
   - ç‚¹å‡»â€œAdd newâ€ï¼Œé€‰æ‹©æ¨¡æ¿æ–‡ä»¶ï¼ˆå¦‚`bed.md`ï¼‰ï¼Œçƒ­é”®å¯é€‰ç•™ç©ºã€‚
   - é‡å¤ä¸º`wake.md`æ·»åŠ ã€‚
   - ç°åœ¨ï¼ŒæŒ‰Ctrl+Pï¼ˆæˆ–Cmd+Pï¼‰æ‰“å¼€å‘½ä»¤é¢æ¿ï¼Œæœç´¢â€œTemplater: Insert bedâ€æˆ–ç±»ä¼¼ï¼Œå³å¯ä¸€é”®è¿è¡Œã€‚

**å¯é€‰**ï¼šä¸ºå‘½ä»¤åˆ†é…çƒ­é”®ï¼ˆå¦‚Ctrl+Alt+B for bedï¼‰ï¼Œå®ç°çœŸæ­£çš„ä¸€é”®æ“ä½œã€‚

## Part 3: æ•°æ®å¯è§†åŒ–â€”â€”ç”¨Dataviewç”Ÿæˆå›¾è¡¨

æœ€åä¸€æ­¥ï¼šè®©æ•°æ®â€œæ´»â€èµ·æ¥ï¼åœ¨ä»»ä½•ç¬”è®°ä¸­æ’å…¥ä»¥ä¸‹DataviewJSä»£ç å—ï¼Œå®ƒä¼šè‡ªåŠ¨åŠ è½½Chart.jsåº“ï¼Œç”Ÿæˆå¤šç§å›¾è¡¨å’Œç»Ÿè®¡ã€‚

```dataviewjs
// --- é…ç½® ---
// 1. è¯·åœ¨è¿™é‡Œå‡†ç¡®å¡«å…¥æ‚¨çš„ç¡çœ è®°å½•æ–‡ä»¶åæˆ–å®Œæ•´è·¯å¾„
const FILE_PATH = "ç¡çœ æ—¥è®°-2025.md";
// --- é…ç½®ç»“æŸ ---

// ------------------------------------------------------------------
// --- æ ¸å¿ƒé€»è¾‘ï¼šåŠ¨æ€åŠ è½½ Chart.js å¹¶æ¸²æŸ“æ‰€æœ‰å†…å®¹ ---
// ------------------------------------------------------------------

// æˆ‘ä»¬æŠŠæ‰€æœ‰çš„æ•°æ®å¤„ç†å’Œæ¸²æŸ“ï¼Œéƒ½åŒ…åœ¨ä¸€ä¸ªå‡½æ•°é‡Œ
const processAndRender = () => {
    const page = dv.page(FILE_PATH);

    if (!page || !page.file || !page.file.lists || page.file.lists.length === 0) {
        dv.paragraph("âŒ **é”™è¯¯ï¼š** æ‰¾ä¸åˆ°æ–‡ä»¶æˆ–æ–‡ä»¶ä¸­æ²¡æœ‰æ•°æ®ã€‚");
        return; // æå‰é€€å‡º
    }

    // å½“å‰æ—¥æœŸï¼ˆå›ºå®šä¸º2025-08-25ï¼Œä»¥åŒ¹é…å½“å‰ä¸Šä¸‹æ–‡ï¼‰
    const currentDate = dv.date("2025-08-25");

    // æ£€æµ‹ iOS è®¾å¤‡
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

    // æ³¨å…¥ CSS æ ·å¼ä»¥ä¼˜åŒ– iOS æ˜¾ç¤º
    const style = document.createElement('style');
    style.textContent = `
        .dataview.container { width: 100% !important; max-width: 100% !important; padding: 0 !important; margin: 0 !important; }
        canvas { width: 100% !important; max-height: 350px !important; }
        .sleep-record-count {
            font-size: 0.8em; /* è°ƒæ•´å­—ä½“å¤§å°ï¼Œä½¿å…¶çœ‹èµ·æ¥åƒå°å­— */
            color: var(--text-muted); /* ä½¿ç”¨ä¸»é¢˜çš„æŸ”å’Œé¢œè‰² */
            text-align: left;
            margin-top: 15px; /* ä¸ä¸Šæ–¹å›¾è¡¨ä¿æŒä¸€äº›é—´è· */
        }
        @media (max-width: 600px) {
            canvas { max-height: 300px !important; }
        }
    `;
    document.head.appendChild(style);

    // 1. æ•°æ®æå–å’Œå¤„ç†
    const records = page.file.lists
        .where(item => item.date && (item.duration || (item.bed && item.wake)))
        .map(item => {
            try {
                const dateStr = item.date.toString().substring(0, 10);
                let durationMillis;
                let bedtimeHour, waketimeHour;

                // ä¼˜å…ˆä½¿ç”¨ duration å­—æ®µ
                if (item.duration) {
                    const durationStr = item.duration.toString();
                    const [hours, minutes] = durationStr.split(':').map(Number);
                    if (!isNaN(hours) && !isNaN(minutes)) {
                        durationMillis = (hours * 60 + minutes) * 60 * 1000;
                    } else {
                        return null; // æ— æ•ˆ duration æ ¼å¼
                    }
                    // å¦‚æœæœ‰ bed å’Œ wakeï¼Œæå–å°æ—¶ç”¨äºåˆ†å¸ƒ
                    if (item.bed && item.wake) {
                        const bedtime = dv.date(dateStr + "T" + item.bed.toString());
                        const waketime = dv.date(dateStr + "T" + item.wake.toString());
                        if (!bedtime || !waketime) return null;
                        bedtimeHour = bedtime.hour + bedtime.minute / 60; // åŒ…å«åˆ†é’Ÿçš„å°æ•°å½¢å¼
                        waketimeHour = waketime.hour + waketime.minute / 60;
                    }
                } else {
                    // æ²¡æœ‰ duration æ—¶ï¼Œä½¿ç”¨ bed å’Œ wake è®¡ç®—
                    const bedtimeStr = item.bed.toString();
                    const waketimeStr = item.wake.toString();
                    const bedtime = dv.date(dateStr + "T" + bedtimeStr);
                    const waketime = dv.date(dateStr + "T" + waketimeStr);
                    if (!bedtime || !waketime) return null;
                    let bedtimeMillis = bedtime.toMillis();
                    let waketimeMillis = waketime.toMillis();
                    if (waketimeMillis <= bedtimeMillis) {
                        waketimeMillis += 24 * 60 * 60 * 1000;
                    }
                    durationMillis = waketimeMillis - bedtimeMillis;
                    bedtimeHour = bedtime.hour + bedtime.minute / 60;
                    waketimeHour = waketime.hour + waketime.minute / 60;
                }

                return {
                    date: dv.date(dateStr),
                    durationMillis: durationMillis,
                    bedtimeHour: bedtimeHour, // å¯èƒ½ä¸º undefined
                    waketimeHour: waketimeHour // å¯èƒ½ä¸º undefined
                };
            } catch (e) { return null; }
        })
        .filter(item => item !== null)
        .values;

    // æˆ‘ä»¬ä¸å†ä½¿ç”¨ dv.duration()ï¼Œè€Œæ˜¯åˆ›å»ºè‡ªå·±çš„æ ¼å¼åŒ–å‡½æ•°
    const formatDurationFromMs = (ms) => {
        if (isNaN(ms) || ms < 0) return "æ— æ•ˆæ—¶é•¿";
        const totalMinutes = Math.round(ms / (1000 * 60));
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        return `${hours}æ—¶ ${minutes}åˆ†`;
    };

    // æ ¼å¼åŒ–å¹³å‡ç¡çœ æ—¶é•¿ä¸ºå°æ—¶ï¼ˆå°æ•°å½¢å¼ï¼Œå¦‚ 6.50ï¼‰
    const formatAvgDurationHours = (ms) => {
        if (isNaN(ms) || ms < 0) return "æ— æ•ˆ";
        return (ms / (1000 * 60 * 60)).toFixed(2);
    };

    // åˆ†ç»„ä¸è®¡ç®—å‡½æ•°
    const groupBy = (data, keyFn) => {
        return data.reduce((acc, item) => {
            const key = keyFn(item);
            if (!acc[key]) acc[key] = [];
            acc[key].push(item);
            return acc;
        }, {});
    };

    // è®¡ç®—å¹³å‡æ—¶é—´ï¼ˆä½¿ç”¨è§’åº¦å¹³å‡æ³•ï¼‰
    const calculateAverages = (group) => {
        const total = group.length;
        if (total === 0) return null;

        const avgDurationMs = group.reduce((sum, r) => sum + r.durationMillis, 0) / total;

        // è®¡ç®—å¹³å‡å…¥ç¡å’Œèµ·åºŠæ—¶é—´ï¼ˆè§’åº¦å¹³å‡æ³•ï¼‰
        const validBedtimes = group.filter(r => r.bedtimeHour !== undefined);
        const validWaketimes = group.filter(r => r.waketimeHour !== undefined);

        const calculateMeanTime = (times) => {
            if (times.length === 0) return null;
            // å°†æ—¶é—´ï¼ˆå°æ—¶ï¼‰è½¬æ¢ä¸ºè§’åº¦ï¼ˆ24å°æ—¶ = 360Â°ï¼‰
            const radians = times.map(t => (t / 24) * 2 * Math.PI);
            const sinSum = radians.reduce((sum, r) => sum + Math.sin(r), 0) / times.length;
            const cosSum = radians.reduce((sum, r) => sum + Math.cos(r), 0) / times.length;
            // è®¡ç®—å¹³å‡è§’åº¦
            let meanAngle = Math.atan2(sinSum, cosSum);
            if (meanAngle < 0) meanAngle += 2 * Math.PI;
            // è½¬æ¢å›å°æ—¶
            let meanHours = (meanAngle / (2 * Math.PI)) * 24;
            if (meanHours >= 24) meanHours -= 24;
            // æ ¼å¼åŒ–ä¸º HH:mm
            const hours = Math.floor(meanHours);
            const minutes = Math.round((meanHours - hours) * 60);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        };

        return {
            "è®°å½•å¤©æ•°": total,
            "å¹³å‡å…¥ç¡": calculateMeanTime(validBedtimes.map(r => r.bedtimeHour)),
            "å¹³å‡èµ·åºŠ": calculateMeanTime(validWaketimes.map(r => r.waketimeHour)),
            "å¹³å‡æ—¶é•¿": formatDurationFromMs(avgDurationMs),
            "avgDurationMs": avgDurationMs
        };
    };

    // è®¡ç®—æ—¶é—´åˆ†å¸ƒï¼ˆå…¥ç¡æˆ–èµ·åºŠï¼‰
    const calculateDistribution = (group, type) => {
        const hours = type === 'bedtime' ? group.map(r => r.bedtimeHour) : group.map(r => r.waketimeHour);
        const validHours = hours.filter(h => h !== undefined);
        const dist = {};
        validHours.forEach(h => {
            const bucket = `${String(Math.floor(h)).padStart(2, '0')}:00`;
            dist[bucket] = (dist[bucket] || 0) + 1;
        });
        return dist;
    };

    // æ¸²æŸ“æŠ¥å‘Š
    dv.header(2, "");
    if (records.length === 0) {
        dv.paragraph("âœ… æ–‡ä»¶å·²æ‰¾åˆ°ï¼Œä½†æœªèƒ½è§£æå‡ºä»»ä½•æœ‰æ•ˆæ•°æ®è¡Œã€‚è¯·ä¸¥æ ¼æ£€æŸ¥æ‚¨çš„æ•°æ®æ ¼å¼æ˜¯å¦ä¸ºï¼š`- [date:: YYYY-MM-DD], [duration:: HH:mm]` æˆ– `- [date:: YYYY-MM-DD], [bed:: HH:mm], [wake:: HH:mm]`");
    } else {
        // åˆ†ç»„å¹¶é™åˆ¶æ•°æ®
        const yearlyData = groupBy(records, r => r.date.year);
        const monthlyData = groupBy(records, r => r.date.toFormat("yyyy-'å¹´' MM'-æœˆ'"));

        // é™åˆ¶æœ€è¿‘12ä¸ªæœˆå’Œ12å¹´
        const limitedMonthlyData = Object.fromEntries(
            Object.entries(monthlyData)
                .sort((a, b) => b[0].localeCompare(a[0]))
                .slice(0, 12)
        );
        const limitedYearlyData = Object.fromEntries(
            Object.entries(yearlyData)
                .sort((a, b) => b[0].localeCompare(a[0]))
                .slice(0, 12)
        );

        // æœ€è¿‘7å¤©æ•°æ®ï¼ˆä»2025-08-25å‘å‰æ¨7å¤©ï¼‰
        const sevenDaysAgo = currentDate.minus({ days: 7 });
        const recent7DaysRecords = records.filter(r => r.date >= sevenDaysAgo && r.date <= currentDate);
        const recent7DaysData = groupBy(recent7DaysRecords, r => r.date.toFormat("MM-dd"));
        const sevenDayAvg = calculateAverages(recent7DaysRecords);

        // æœ€è¿‘30å¤©æ•°æ®ï¼ˆä»2025-08-25å‘å‰æ¨30å¤©ï¼‰
        const thirtyDaysAgo = currentDate.minus({ days: 30 });
        const recent30DaysRecords = records.filter(r => r.date >= thirtyDaysAgo && r.date <= currentDate);
        const recent30DaysData = groupBy(recent30DaysRecords, r => r.date.toFormat("MM-dd"));
        const thirtyDayAvg = calculateAverages(recent30DaysRecords);

        // --- æ¸²æŸ“è¡¨æ ¼çš„æ¨¡æ¿å‡½æ•° (å·²ä¿®æ”¹) ---
        const renderTable = (header, data) => {
            const rows = Object.keys(data).sort((a, b) => b.localeCompare(a)).map(key => {
                const avg = calculateAverages(data[key]);
                // ä¿®æ”¹è¿™é‡Œï¼Œå»æ‰äº† avg.è®°å½•å¤©æ•°
                return [avg.å¹³å‡æ—¶é•¿, avg.å¹³å‡å…¥ç¡ || "æ— æ•°æ®", avg.å¹³å‡èµ·åºŠ || "æ— æ•°æ®", key];
            });
            // ä¿®æ”¹è¿™é‡Œï¼Œå»æ‰äº†è¡¨å¤´çš„ "è®°å½•å¤©æ•°"
            dv.table(["å¹³å‡æ—¶é•¿", "å¹³å‡å…¥ç¡", "å¹³å‡èµ·åºŠ", header], rows);
        };

        // --- æ¸²æŸ“å¹³å‡ç¡çœ æ—¶é•¿æŸ±çŠ¶å›¾çš„å‡½æ•° ---
        const renderAvgChart = (data, title) => {
            const labels = Object.keys(data).sort((a, b) => a.localeCompare(b));
            const chartValues = labels.map(key => {
                const avg = calculateAverages(data[key]);
                return (avg.avgDurationMs / (1000 * 60 * 60)).toFixed(2);
            });
            const canvas = dv.el("canvas");
            canvas.style.width = '100%';
            canvas.style.height = '300px';
            canvas.width = window.innerWidth * window.devicePixelRatio;
            canvas.height = 300 * window.devicePixelRatio;
            dv.container.style.width = '100%';
            dv.container.appendChild(canvas);
            const chartConfig = {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `${title} å¹³å‡ç¡çœ æ—¶é•¿ (å°æ—¶)`,
                        data: chartValues,
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true, title: { display: true, text: 'å°æ—¶' } },
                        x: {
                            title: { display: true, text: title === 'æœˆ' ? 'æœˆä»½' : 'å¹´ä»½' },
                            ticks: {
                                font: { size: isIOS ? 10 : 12 },
                                maxRotation: isIOS ? 45 : 0,
                                autoSkip: true
                            }
                        }
                    },
                    plugins: {
                        legend: { position: 'top', labels: { font: { size: isIOS ? 10 : 12 } } },
                        tooltip: { bodyFont: { size: isIOS ? 10 : 12 } }
                    },
                    animation: { duration: isIOS ? 0 : 1000 }
                }
            };
            new Chart(canvas.getContext('2d'), chartConfig);
        };

        // --- æ¸²æŸ“å †å å…¥ç¡/èµ·åºŠæ—¶é—´åˆ†å¸ƒå›¾ï¼ˆæœ€è¿‘30å¤©æ±‡æ€»ï¼‰ ---
        const renderStackedDistChart = (data, title, isRecent30Days = false) => {
            const allLabels = [];
            let bedtimeDist, waketimeDist;

            if (isRecent30Days) {
                // å¯¹äºæœ€è¿‘30å¤©ï¼Œæ±‡æ€»æ‰€æœ‰è®°å½•çš„å…¥ç¡å’Œèµ·åºŠæ—¶é—´åˆ†å¸ƒ
                bedtimeDist = calculateDistribution(data, 'bedtime');
                waketimeDist = calculateDistribution(data, 'waketime');
                Object.keys(bedtimeDist).concat(Object.keys(waketimeDist)).forEach(bucket => {
                    if (!allLabels.includes(bucket)) allLabels.push(bucket);
                });
            } else {
                // å¯¹äºæœˆæˆ–å¹´ï¼Œåˆ†åˆ«è®¡ç®—æ¯ä¸ªåˆ†ç»„çš„åˆ†å¸ƒ
                Object.keys(data).forEach(key => {
                    const bd = calculateDistribution(data[key], 'bedtime');
                    const wd = calculateDistribution(data[key], 'waketime');
                    Object.keys(bd).concat(Object.keys(wd)).forEach(bucket => {
                        if (!allLabels.includes(bucket)) allLabels.push(bucket);
                    }
                });
            }

            const sortedLabels = allLabels.sort();
            const canvas = dv.el("canvas");
            canvas.style.width = '100%';
            canvas.style.height = '300px';
            canvas.width = window.innerWidth * window.devicePixelRatio;
            canvas.height = 300 * window.devicePixelRatio;
            dv.container.style.width = '100%';
            dv.container.appendChild(canvas);
            const chartData = {
                labels: sortedLabels,
                datasets: isRecent30Days ? [
                    {
                        label: 'å…¥ç¡æ—¶é—´',
                        data: sortedLabels.map(label => bedtimeDist[label] || 0),
                        backgroundColor: 'rgba(54, 162, 235, 0.4)',
                        stack: 'Stack 0'
                    },
                    {
                        label: 'èµ·åºŠæ—¶é—´',
                        data: sortedLabels.map(label => waketimeDist[label] || 0),
                        backgroundColor: 'rgba(75, 192, 192, 0.4)',
                        stack: 'Stack 0'
                    }
                ] : [
                    ...Object.keys(data).sort((a, b) => a.localeCompare(b)).map((key, i) => ({
                        label: `${key} å…¥ç¡`,
                        data: sortedLabels.map(label => calculateDistribution(data[key], 'bedtime')[label] || 0),
                        backgroundColor: `rgba(54, 162, 235, ${0.4 - i * 0.1})`,
                        stack: `Stack ${i}`
                    })),
                    ...Object.keys(data).sort((a, b) => a.localeCompare(b)).map((key, i) => ({
                        label: `${key} èµ·åºŠ`,
                        data: sortedLabels.map(label => calculateDistribution(data[key], 'waketime')[label] || 0),
                        backgroundColor: `rgba(75, 192, 192, ${0.4 - i * 0.1})`,
                        stack: `Stack ${i}`
                    }))
                ]
            };
            const chartConfig = {
                type: 'bar',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            stacked: true,
                            title: { display: true, text: 'æ—¶é—´' },
                            ticks: {
                                font: { size: isIOS ? 10 : 12 },
                                maxRotation: isIOS ? 45 : 0,
                                autoSkip: true
                            }
                        },
                        y: {
                            stacked: true,
                            title: { display: true, text: 'æ¬¡æ•°' },
                            ticks: { font: { size: isIOS ? 10 : 12 } }
                        }
                    },
                    plugins: {
                        legend: { position: 'top', labels: { font: { size: isIOS ? 10 : 12 } } },
                        tooltip: { bodyFont: { size: isIOS ? 10 : 12 } }
                    },
                    animation: { duration: isIOS ? 0 : 1000 }
                }
            };
            new Chart(canvas.getContext('2d'), chartConfig);
        };

        // --- æ¸²æŸ“ç¡çœ æ—¶é•¿è¶‹åŠ¿æŠ˜çº¿å›¾ï¼ˆ7å¤©æˆ–30å¤©ï¼‰ ---
        const renderTrendChart = (data, title, days) => {
            const labels = Object.keys(data).sort((a, b) => a.localeCompare(b));
            const chartValues = labels.map(key => {
                const avg = calculateAverages(data[key]);
                return (avg.avgDurationMs / (1000 * 60 * 60)).toFixed(2);
            });
            const canvas = dv.el("canvas");
            canvas.style.width = '100%';
            canvas.style.height = '300px';
            canvas.width = window.innerWidth * window.devicePixelRatio;
            canvas.height = 300 * window.devicePixelRatio;
            dv.container.style.width = '100%';
            dv.container.appendChild(canvas);
            const chartConfig = {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `${title} ç¡çœ æ—¶é•¿è¶‹åŠ¿ (å°æ—¶)`,
                        data: chartValues,
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        borderColor: 'rgba(255, 99, 132, 1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'å°æ—¶' },
                            ticks: { font: { size: isIOS ? 10 : 12 } }
                        },
                        x: {
                            title: { display: true, text: 'æ—¥æœŸ' },
                            ticks: {
                                font: { size: isIOS ? 10 : 12 },
                                maxRotation: isIOS ? 45 : 0,
                                autoSkip: days === 7 ? false : true // 7å¤©æ˜¾ç¤ºæ‰€æœ‰æ ‡ç­¾
                            }
                        }
                    },
                    plugins: {
                        legend: { position: 'top', labels: { font: { size: isIOS ? 10 : 12 } } },
                        tooltip: { bodyFont: { size: isIOS ? 10 : 12 } }
                    },
                    animation: { duration: isIOS ? 0 : 1000 }
                }
            };
            new Chart(canvas.getContext('2d'), chartConfig);
        };

        // --- æŒ‰é¡ºåºæ¸²æŸ“æ‰€æœ‰å†…å®¹ ---
        dv.header(3, "");
        dv.header(4, `è¿‘7å¤©ç¡çœ è¶‹åŠ¿ å¹³å‡: ${sevenDayAvg ? formatAvgDurationHours(sevenDayAvg.avgDurationMs) : 'æ— æ•°æ®'}å°æ—¶`);
        renderTrendChart(recent7DaysData, "è¿‘7å¤©", 7);

        dv.header(3, "");
        dv.header(4, `æœ€è¿‘30å¤©ç¡çœ æ—¶é•¿è¶‹åŠ¿ å¹³å‡: ${thirtyDayAvg ? formatAvgDurationHours(thirtyDayAvg.avgDurationMs) : 'æ— æ•°æ®'}å°æ—¶`);
        renderTrendChart(recent30DaysData, "æœ€è¿‘30å¤©", 30);
        dv.header(4, "æœ€è¿‘30å¤©å…¥ç¡/èµ·åºŠæ—¶é—´åˆ†å¸ƒ (å †å )");
        renderStackedDistChart(recent30DaysRecords, "æœ€è¿‘30å¤©", true);

        dv.header(3, "æŒ‰æœˆç»Ÿè®¡");
        renderTable("æœˆä»½", limitedMonthlyData);
        renderAvgChart(limitedMonthlyData, "æœˆ");

        dv.header(3, "æŒ‰å¹´ç»Ÿè®¡");
        renderTable("å¹´ä»½", limitedYearlyData);
        renderAvgChart(limitedYearlyData, "å¹´");
        dv.header(4, "æœ¬å¹´å…¥ç¡/èµ·åºŠæ—¶é—´åˆ†å¸ƒ (å †å )");
        renderStackedDistChart(limitedYearlyData, "å¹´");
        dv.header(4, "æœ¬å¹´ç¡çœ æ—¶é•¿è¶‹åŠ¿");
        renderTrendChart(limitedYearlyData, "å¹´", 365);

        // --- æ–°å¢ï¼šåœ¨æœ€ä¸‹æ–¹æ˜¾ç¤ºæ€»è®°å½•æ¡æ•° ---
        dv.el('p', `ğŸ›Œ ç¡çœ è®°å½•å…± ${records.length} æ¡`, { cls: 'sleep-record-count' });
    }
};

// ------------------------------------------------------------------
// --- åŠ¨æ€åŠ è½½è„šæœ¬çš„é€»è¾‘ ---
// ------------------------------------------------------------------

const loadScripts = () => {
    return new Promise((resolve, reject) => {
        if (typeof Chart !== 'undefined') {
            resolve();
            return;
        }

        const chartScript = document.createElement('script');
        chartScript.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js';
        document.head.appendChild(chartScript);

        chartScript.onload = () => resolve();
        chartScript.onerror = () => reject(new Error("æ— æ³•åŠ è½½ Chart.js åº“"));
    });
};

loadScripts()
    .then(() => {
        processAndRender();
    })
    .catch((error) => {
        dv.paragraph(`âš ï¸ **é”™è¯¯ï¼š** ${error.message}ã€‚å›¾è¡¨å¯èƒ½ä¸å¯ç”¨ï¼Œä½†è¡¨æ ¼å°†ç»§ç»­æ˜¾ç¤ºã€‚`);
        processAndRender();
    });
```
````

**æç¤º**ï¼šä»£ç ä¼šä»CDNåŠ è½½Chart.jsï¼Œç¡®ä¿ä½ çš„Obsidianæœ‰ç½‘ç»œæƒé™ã€‚å¦‚æœå›¾è¡¨ä¸æ˜¾ç¤ºï¼Œæ£€æŸ¥æ–‡ä»¶è·¯å¾„å’Œæ•°æ®æ ¼å¼ã€‚

## ç»“è¯­

æ­å–œï¼ä½ ç°åœ¨æ‹¥æœ‰äº†ä¸€å¥—å®Œæ•´çš„Obsidianç¡çœ è‡ªåŠ¨åŒ–ç³»ç»Ÿã€‚ä»æ‰‹åŠ¨è®°å½•çš„çƒ¦æ¼ï¼Œåˆ°ä¸€é”®æ“ä½œå’Œæ™ºèƒ½å›¾è¡¨çš„ä¾¿åˆ©ï¼Œè¿™ä¸ä»…ä»…æ˜¯å·¥å…·ï¼Œæ›´æ˜¯ç”Ÿæ´»ä¼˜åŒ–çš„ä¸€éƒ¨åˆ†ã€‚æˆ‘çš„6å°æ—¶è°ƒè¯•ç»å†ï¼Œå°±æ˜¯ä¸ºäº†è®©ä½ é¿å¼€æ‰€æœ‰å‘ï¼Œç›´æ¥ä¸Šæ‰‹ã€‚å¦‚æœä½ é‡åˆ°é—®é¢˜ï¼Œæ¬¢è¿åœ¨è¯„è®ºåŒºäº¤æµâ€”â€”æˆ–è®¸æˆ‘ä»¬èƒ½ä¸€èµ·å®Œå–„å®ƒã€‚

ä½œä¸ºæ–°æ‰‹åšä¸»ï¼Œæˆ‘å¸Œæœ›è¿™ç¯‡æ–‡ç« èƒ½å¸®åŠ©æ›´å¤šäººã€‚å¦‚æœä½ å–œæ¬¢ï¼Œåˆ†äº«ç»™æœ‹å‹å§ï¼æœªæ¥ï¼Œæˆ‘è®¡åˆ’å½•åˆ¶è§†é¢‘æ•™ç¨‹ï¼Œè¿›ä¸€æ­¥ä¼ æ’­è¿™ä¸ªideaã€‚æ„Ÿè°¢é˜…è¯»ï¼Œä¸‹æ¬¡è§ï¼

